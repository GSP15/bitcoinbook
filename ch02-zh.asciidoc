[[ch02_bitcoin_overview]]
== 比特币如何工作

=== 交易、区块、挖掘、和区块链

((("bitcoin", "overview of", id="BCover02")))((("central trusted authority")))((("decentralized systems", "bitcoin overview", id="DCSover02")))与传统的银行和支付系统不同，比特币系统基于去中心化的信托。在比特币中，信托是作为比特币网络中不同参与者的互动中自然产生的属性取得的，这取代了中央信托权威。在这一章中，我们将通过在比特币系统中跟踪一笔交易来从一个比较高的角度监视比特币，观察它如何成为“被信任的”并为比特币的分布式共识机制所接受，而最终被记录到区块链 —— 所有交易的分布式总账中。后续的章节将会深入探究交易、网络、和挖掘背后的技术。

==== 比特币概览

在<<比特币概览>>展示的概览图中，我们看到比特币系统由使用包含秘钥的钱包的用户、在整个网络上传播的交易、以及（通过竞争性计算）生产共识区块链 —— 所有交易的权威性总账 —— 的矿工组成。

((("blockchain explorer sites")))这一章中的每一个例子都基于比特币网络中发生过的真实的交易，通过从一个钱包发送资金到另一个钱包来模拟用户（Joe、Alice、Bob、和 Gopesh）之间的互动。在我们从比特币网络跟踪一笔交易到区块链的过程中，我们将使用一个 _区块链浏览器_ 网站来可视化每一个步骤。区块链浏览器是一个 web 应用程序，像一个比特币搜索引擎一样工作，它允许你检索地址、交易、以及区块并看到它们之间的联系和流程。

[[bitcoin-overview]]
.比特币概览
image::images/mbc2_0201.png["Bitcoin Overview"]

((("Bitcoin Block Explorer")))((("BlockCypher Explorer")))((("blockchain.info")))((("BitPay Insight")))流行的区块链浏览器有：

* https://blockexplorer.com[Bitcoin Block Explorer]
* https://live.blockcypher.com[BlockCypher Explorer]
* https://blockchain.info[blockchain.info]
* https://insight.bitpay.com[BitPay Insight]

它们中的每一个都有搜索功能，可以输入一个比特币地址、交易哈希码、区块号、或者区块哈希码进行搜索并从比特币网络中获取相应的信息。在每一个交易或区块的例子中，我们都将提供一个 URL，这样你就可以自己查询它来探究它的细节。

[[cup_of_coffee]]
==== 买一杯咖啡

((("use cases", "buying coffee", id="UCcoffee02")))在前一章中介绍的 Alice 是一个刚刚获得她第一个比特币的新用户。在<<getting_first_bitcoin>>中，Alice 见到了她的朋友 Joe 并用现金兑换了一些比特币。Joe 创建的交易向 Alice 的钱包提供了 0.10 BTC 的资金。现在 Alice 将要做出她的第一笔零售交易，在加利福尼亚帕罗奥图的 Bob 的咖啡店里买一杯咖啡。

((("exchange rates", "determining")))Bob 的咖啡店最近通过将比特币选项添加到它的积分系统中而开始接受比特币支付了。Bob 的咖啡店的价格是用当地货币（美元）罗列的，但是在收银台，客人可以选择使用美元还是比特币支付。Alice 点了一杯咖啡，Bob 在收银机中输入，就像他为所有的交易做的那样。积分系统自动地将总价按照现行市场汇率从美元换算为比特币，并将价格用两种货币显示出来：

----
Total:
$1.50 USD
0.015 BTC
----


((("millibits")))Bob 说：“1.5美元，或15毫比特币”

((("payment requests")))((("QR codes", "payment requests")))Bob 的积分系统还会自动生成一个包含 _支付请求_ 的特殊二维码（参见<<payment-request-QR>>）。

与仅仅包含目标比特币地址的二维码不同，一个支付请求二维码是一个二维码编码的 URL，包含一个目标地址、一个支付金额、和一个诸如“Bob's Cafe”这样的范用描述。这允许比特币钱包应用程序提前填写好用来发送支付的信息，同时向用户显示一个人类可读的描述。你可以使用比特币钱包应用来扫描这个二维码来看看 Alice 看到的是什么。

[[payment-request-QR]]
.支付请求二维码
image::images/mbc2_0202.png["payment-request"]

[TIP]
====
((("QR codes", "warnings and cautions")))((("transactions", "warnings and cautions")))((("warnings and cautions", "avoid sending money to addresses appearing in book")))用你的钱包扫描来看看地址和金额，但不要打钱。
====
[[payment-request-URL]]
.支付请求二维码编码了如下 URL，定义在 BIP-21：
----
bitcoin:1GdK9UzpHBzqzX2A9JFP3Di4weBwqgmoQA?
amount=0.015&
label=Bob%27s%20Cafe&
message=Purchase%20at%20Bob%27s%20Cafe

URL 的组成部分

一个比特币地址："1GdK9UzpHBzqzX2A9JFP3Di4weBwqgmoQA"
支付金额："0.015"
一个收款地址标签："Bob's Cafe"
一个支付的描述："Purchase at Bob's Cafe"
----

Alice 用她的智能手机扫描了屏幕上的二维码。她的手机上显示了一笔到 +Bob's Cafe+ 的 +0.0150 BTC+ 的支付，她选择“发送”来授权支付。几秒钟之后（与信用卡授权花费的时间差不多），Bob 在收银机上看到并完成了这笔交易。

我们将在后续的内容中详细检视这笔交易。我们将看到 Alice 的钱包如何构建它、它如何在网络上传播、它如何被验证、以及最终，Bob 如何能够在后续的交易中花费这笔金额。

[NOTE]
====
((("fractional values")))((("milli-bitcoin")))((("satoshis")))比特币网络可以用很小的价值进行交易，比如，从毫比特币（千分之一个比特币）到一亿分之一个比特币，这称为一个 satoshi。我们将在本书通篇使用“比特币”这个术语来指代任意数量的比特币货币，从最小的单位（1 satoshi）到可能被挖掘出来的比特币的总量（21,000,000）。
====

你可以使用区块链浏览器网站来检视 Alice 与 Bob 的咖啡店在区块链上的交易（<<view_alice_transaction>>）：

[[view_alice_transaction]]
.在 https://blockexplorer.com/tx/0627052b6f28912f2703066a912ea577f2ce4da4caa5a5fbd8a57286c345c2f2[blockexplorer.com] 上查看 Alice 的交易
====
----
https://blockexplorer.com/tx/0627052b6f28912f2703066a912ea577f2ce4da4caa5a5fbd8a57286c345c2f2
----
====

=== 比特币交易

((("transactions", "defined")))简单地说，一笔交易告诉网络，一部分比特币价值的所有者授权将这部分价值转移给另一个所有者。现在新的所有者可以通过创建另一笔交易，授权转移给另个一所有者来花费这部分比特币，在一个所有权的链条中如此反复。

==== 交易的收入和输出

((("transactions", "overview of", id="Tover02")))((("outputs and inputs", "basics of")))交易就像是复式簿记总账中的一行。每笔交易都包含一个或多个“输入”，就像对一个比特币账户收款。在交易的另一端，有一个或多个“输出”，就像对一个比特币账户存款。((("fees", "transaction fees")))输入和输出（收款和存款）不一定会累计为相同的金额。相反，输出的累计会稍小于输入，而这个差额就代表隐含的 _交易费_，这一小笔费用会支付给将这笔交易纳入总账的矿工。在<<transaction-double-entry>>中，一笔比特币交易被展示为一个簿记总账的一个记录。

交易还包含了价值被花费的每部分比特币的所有权证明，其形式就是所有者的数字签名，它可以被任何人独立地验证。((("spending bitcoin", "defined")))用比特币的术语讲，“花费”就是签署一笔交易，这笔交易将价值从前一个交易转移到一个由比特币地址所识别的新所有者手中。

[[transaction-double-entry]]
.作为一个复式簿记的交易
image::images/mbc2_0203.png["Transaction Double-Entry"]

==== Transaction Chains

((("chain of transactions")))Alice 向 Bob 的咖啡店进行的支付使用了前一笔交易的输出作为它的输入。在上一章中，Alice 从她的朋友 Joe 那里用现金换回了一些比特币。那笔交易创建了一个被 Alice 的秘钥锁定的比特币价值。她与 Bob 的咖啡店的新交易引用了前一笔交易作为一个输入，并创建了新的输出来支付一杯咖啡并接收找零。这些交易形成了一个链条，其中最后一笔交易的输入对应于前一笔交易的输出。Alice 的秘钥提供了解锁先前交易输出的签名，从而向比特币网络证明了她拥有这些资金。她将咖啡的付款添附到 Bob 地址，从而“阻塞”了输出 —— 要求 Bob 生成一个签名才能花费这笔资金。这代表的价值在 Alice 和 Bob 之间的转移。这个从 Alice 到 Bob 的交易链条被展示在<<blockchain-mnemonic>>中。

[[blockchain-mnemonic]]
.一个交易的链条，其中一笔交易的输出时下一笔交易的输入action
image::images/mbc2_0204.png["Transaction chain"]

==== 找零

((("change, making")))((("change addresses")))((("addresses", "change addresses")))许多比特币交易会包含同时引用了新所有者地址和当前所有者地址的输出，这称为 _找零_ 地址。这是因为交易的输入，比如钞票，是无法分割的。如果你在商店购买一个 $5 美元的商品，而使用 $20 美元的钞票支付，那么你就会收到 $15 美元的找零。同样的概念也适用于比特币交易的输入。如果你购买价值 5 比特币的商品但是是只有 20 比特币的输入可用，那么你就可以发送一个 5 比特币的输出给商店，一个 15 比特币的输出返还给自己作为找零（减去适当的交易费）。重要的是，找零的地址不必非得和输入的地址相同，而且为了私密性它的地址经常是一个所有者钱包的新地址。

在构建一个用户请求的支付时，不同的钱包可能会使用不同的策略来聚合输入。它们可能聚合许多小的输入，或者使用一个大于等于期望的支付额的输入。除非钱包能够以一种正好等于支付额外加交易费的方式聚合输入，否则钱包将需要生成一些找零。这与人们如何处理现金十分相似。如果你总是使用口袋中最大额的钞票，那么你的口袋最终将满是零钱。如果你只使用零钱，那么你将总是只持有大额钞票。人们会潜意识地在这两个极端中寻找平衡，而比特币钱包的开发者们在努力用编程实现这种平衡。

((("transactions", "defined")))((("outputs and inputs", "defined")))((("inputs", see="outputs and inputs")))概括地说，_交易_ 将价值从 _交易输入_ 转移至 _交易输出_。一个输入是对前一个交易输出的引用，显示价值从何而来。一个交易输出将具体的价值指向一个新的所有者的比特币地址，并且可以包含一个找零输出返还给原始的所有者。一笔交易的输出可以作为一笔新的交易的输入，如此随着价值从所有者到所有者间的转移形成了一个所有权链条（见<<blockchain-mnemonic>>）。

==== 常见的交易形式

最常见的交易形式就是从一个地址向另一个地址进行支付，这通常包含一些“找零”返还给原始所有者。这种类型的交易拥有一个输入和两个输出，如<<transaction-common>>所示。

[[transaction-common]]
.最常见的交易
image::images/mbc2_0205.png["Common Transaction"]

另一种常见的交易形式是，将几个输入聚合为一个单独的输入（参见<<transaction-aggregating>>）。这相当于在真实世界中将一堆硬币和钞票兑换为一张大额钞票。这样的交易有时是由钱包应用生成的，来清理许多作为支付找零收到的小额输入。

[[transaction-aggregating]]
.聚合资金的交易
image::images/mbc2_0206.png["Aggregating Transaction"]

最后，另一种经常能够在比特币总账中看到的交易形式是，一笔交易将一个输入发放给代表多个收款人的多个输出（参见<<transaction-distributing>>）。这种类型的交易有时被商业实体用来发放资金，比如在处理向多个雇员发工资的时候。

[[transaction-distributing]]
.发放资金的交易
image::images/mbc2_0207.png["Distributing Transaction"]

=== 构建一个交易

((("transactions", "constructing", id="Tconstruct02")))((("wallets", "constructing transactions")))Alice 的钱包应用程序包含所有按照 Alice 的要求选择恰当输入和输出来构建交易的逻辑。Alice 只需要指定目标和金额，而其他的事情会在钱包应用程序内部发生，她并不知晓细节。重要的是，一个钱包应用即使在完全离线的状态也可以构建交易。就像在家里写好支票，稍后再将它装进信封邮到银行，交易并不需要连接着比特币网络才能构建和签署。

==== 取得正确的输入

((("outputs and inputs", "locating and tracking inputs")))Alice 的钱包应用必须首先找到足够的输入来支付她想发送给 Bob 的金额。大多数钱包都持续地追踪着属于这个钱包中地址的所有可用输出。因此，Alice 的钱包将会含有一个与 Joe 交易的输出的拷贝，它是在兑换现金时产生的（参见<<getting_first_bitcoin>>）。一个作为完整节点客户端运行的比特币钱包应用实际上包含着区块链中每一笔交易的每一个未花费的输出的拷贝。这允许钱包构建交易输入，同时因为拥有正确的输入而能够快速地验证到来的交易。然而，由于完整节点客户端会占用大量的磁盘空间，大多数用户钱包运行的是“轻量”客户端 —— 仅追踪用户自己的未花费输出。
	
如果钱包应用没有维护一个未花费的交易输出的拷贝，那么它可以查询比特币网络来取得这个信息：使用不同供应商提供的各种 API，或者使用应用程序编程接口（API）调用向一个完整节点询问。<<example_2-2>>展示了一个 API 请求，它构建为一个向指定 URL 发起的 HTTP GET 命令。这个 URL 将返回一个地址的所有未花费的交易输出，给任意应用程序提供为了花费而构建交易输入所需的信息。我们使用简单的命令行 HTTP 客户端 _cURL_ 来取得它的应答。

[[example_2-2]]
.为 Alice 的比特币地址查找所有的未花费输出
====
[source,bash]
----
$ curl https://blockchain.info/unspent?active=1Cdid9KFAaatwczBwBttQcwXYCpvK8h7FK
----
====

[source,json]
----
{
 
	"unspent_outputs":[

		{
			"tx_hash":"186f9f998a5...2836dd734d2804fe65fa35779",
			"tx_index":104810202,
			"tx_output_n": 0,	
			"script":"76a9147f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a888ac",
			"value": 10000000,
			"value_hex": "00989680",
			"confirmations":0
		}
  
	]
}
----


<<example_2-2>>中的应答展示了一个在 Alice 的地址 +1Cdid9KFAaatwczBwBttQcwXYCpvK8h7FK+ 所有权之下的未花费的输出。这个应答包含了一个交易的引用 —— 而这个交易包含着这个未花费输出（来自 Joe 的支付）—— 以及它以 satoshi 为单位的价值，一千万，等价于 0.10 个比特币。使用这个信息，Alice 的钱包应用就可以构建一个交易来将这份价值转移给一个新所有者的地址了。

[TIP]
====
View the http://bit.ly/1tAeeGr[transaction from Joe to Alice].
====

如你所见，Alice 的钱包中有一个未花费的输出，其中有足够的比特币来支付一杯咖啡。如果不是这样的话，Alice 的钱包应用可能不得不在一堆很小的未花费输出中“翻箱倒柜”，就像从钱包中不停拣出硬币直到足够支付这杯咖啡一样。正如我们将在下一节中看到的那样，在钱包应用创建交易输出（支付）时，这两种情况都可能需要找回一些零钱。

==== 创建输出

((("outputs and inputs", "creating outputs")))一个交易输出是以一个脚本的形式被创建的，这个脚本在价值上造成了一种阻塞，而且仅能通过为这个脚本引入一个解才能释放。简而言之，Alice 的交易输出将含有一个脚本，述说着这样的话：“这个输出仅对能够出示签名的人进行支付，而签名是由 Bob 的公共地址所对应的秘钥生成的。” 因为只有 Bob 拥有带着对应自己地址的秘钥的钱包，所以只有 Bob 的钱包可以出示这样的签名来释放这个输出。因此，Alice 用从 Bob 那里要求签名的方式“阻塞”了输出的价值。

这笔交易还包含第二个输出，因为 Alice 的资金是 0.10 BTC 形式的输出，对于 0.015 BTC 一杯的咖啡来说太多了。所以 Alice 需要 0.085 BTC 的找零。Alice 的找零支付是由 Alice 的钱包在向 Bob 进行支付的同一个交易中，作为一个输出创建的。实质上，Alice 的钱包将它的资金分解为两个支付：一个给 Bob，一个还给她自己。然后她就可以在以后的交易中使用（花费）这个找零输出了。

最后，为了使这笔交易能够被网络及时处理，Alice 的钱包引用将加入一点儿费用。这没有在交易中明示；它是隐含在输入和输出的差额中的。如果 Alice 仅仅创建了 0.0845 作为第二个输出，而非 0.085 的找零，那么就会剩余 0.0005 BTC（半毫比特币）。输入的 0.10 BTC 没有被两个输出完全花费完，因为它们加起来小于 0.10。这其中的差额就是 _交易费_ —— 由矿工收取，作为验证以及将交易纳入将要被记录到区块链的区块中的费用.

产生的交易可以使用区块链浏览器看到，如图<<transaction-alice>>所示。

[[transaction-alice]]
[role="smallerseventyfive"]
.Alice 与 Bob 的咖啡店的交易
image::images/mbc2_0208.png["Alice Coffee Transaction"]

[[transaction-alice-url]]
[TIP]
====
View the http://bit.ly/1u0FIGs[transaction from Alice to Bob's Cafe].
====

==== 将交易加入总账

由 Alice 的钱包应用创建的交易有 258 字节长，包含确认资金所有权以及分配给新所有者所需的一切信息。现在，这笔交易必须被传送到比特币网络，在那里它将成为区块链的一部分。下一节中我们将看到一笔交易是如何成为一个新区块的一部分的，以及这个区块是如何被“挖掘”的。最后，我们将看到这个新区块，一旦被加入区块链，是如何随着更多区块被加入而逐渐为网络所信任的。

===== 传输这笔交易

((("propagation", "process of")))因为交易包含着处理所需的所有信息，所以它从何处、如何传送到比特币网络无关紧要。比特币网络是一个点对点网络，每个比特币客户端通过连接着其他几个比特币客户端参与其中。比特币网络的目的是向所有参与者传播交易与区块。

===== 如何传播

((("bitcoin nodes", "defined")))((("nodes", see="bitcoin nodes")))任何系统，比如服务器、桌面应用、或者钱包，只要通过“讲”比特币协议参与比特币网络就称为一个 _比特币节点_。Alice 的钱包应用可以通过任意种类的连接 —— 有线、WiFi、移动网络等 —— 向任何它连接着的比特币节点发送新的交易。她的比特币钱包不必直接连接到 Bob 的比特币钱包，而且她也不必非得使用咖啡店提供的因特网连接，虽然这两种选择也都是行得通的。((("propagation", "flooding technique")))((("flooding technique")))任何比特币节点在接收到一个它之前从未见到过的合法交易时，都会立即向它连接着的其他节点转发这笔交易，这种传播技术称为 _洪泛_。如此，这笔交易会快速传遍真个点对点网络，在几秒中之内到达大部分节点。

===== Bob 的视角

如果 Bob 的比特币钱包应用直接连接着 Alice 的钱包应用，那么 Bob 的钱包应用可能就是第一个收到交易的节点。然而，即便 Alice 的钱包通过其他及节点发送交易，它也会在几秒钟之内到达 Bob 的钱包。Bob 的钱包将会立即将 Alice 的交易识别为一个到来的支付，因为它含有 Bob 的秘钥能够释放的输出。Bob 的钱包应用还可以独立地验证这笔交易是合规的，使用前一个未花费的输入，并且包含足够的交易费来使它被纳入下一个区块。此时此刻 Bob 可以推测，带有一点点风险，这笔交易将很快被纳入一个区块并被确认。

[TIP]
====
((("confirmations", "of small-value transactions", secondary-sortas="small-value transactions")))一个对于比特币交易的常见误解是，认为它们必须等待一个新区块 10 分钟才能“被确认”，或者至多为了六次确认而等待 60 分钟。虽然确认本身保证了交易被整个网络所接受，但对于一杯咖啡这样的小额商品来说，这样的延迟是不必要的。一个商户可能会在没有确认的情况下接受一笔小额交易，其风险不会比一次没有 ID 或签字的信用卡支付高，就像今天商户们通常所接受的那样。((("", startref="Tconstruct02")))
====

=== 比特币挖掘

((("mining and consensus", "overview of", id="MACover02")))((("blockchain (the)", "overview of mining", id="BToverview02")))现在 Alice 的交易已经在比特币网络上传播了。在它被一种称为 _挖掘_ 的处理验证并纳入一个区块之前，它不会成为 _区块链_ 的一部分。详细的解说参见<<mining>>。

比特币系统的信托基于计算。交易被打包进 _区块_，这个过程这要求庞大的计算量来证明，但仅仅需要很小的计算量来验证它被证明了。在比特币中，挖掘处理服务于两个目的：

* ((("mining and consensus", "consensus rules", "security provided by")))((("consensus", see="mining and consensus")))挖掘节点通过参照比特币的 _共识规则_ 验证所有的交易。因此，挖掘通过拒收不合法或违规的交易来为比特币交易提供安全。
* 挖掘会在每个节点上产生新的比特币，就像一个中央银行印刷新的钞票一样。每个区块产生的比特币的数量是受到限制的，而且遵循着固定的发行进度而随着时间减少。

挖掘在成本与收益上取得了很好的平衡。挖掘使用电力来解决数学问题。一个成功的矿工将会以新比特币和交易费的形式收取 _报酬_。但是，报酬仅会在矿工为了满足 _共识_ 规则而正确地验证了所有的交易后才会被收取。这种微妙的平衡在没有中央权威的情况下为比特币提供了安全。

一种描述挖掘的好方法是，它就像一个巨大“数独”游戏竞赛，当某人找到一个解时重新开始，而且它的难度会自动调整以保证大约 10 分钟才能找到一个解。想象一个拥有好几千行和列的巨大“数独”游戏。如果我给你看一个已经完成的结果，那么你就能十分快速地验证它。但是，如果这个“数独”只有几个方块被填好而其他的都是空白，那就要花很大力气才能解开了！“数独”的难度可以通过改变它的大小（更多或更少的行与列）来调整，但即便它很大也可以被十分容易地验证。在比特币中使用的“数独”基于一种哈希密码算法，它显示出相似的性质：它不对称地难以解决但易于验证，而且难度可以被调整。

((("mining and consensus", "mining farms and pools")))在<<user-stories>>中，我们介绍了((("use cases", "mining for bitcoin"))) Jing，一位上海的企业家。Jing 运营着一个 _矿场_，这种生意运行着成百上千的特殊的挖掘计算机，争取挖掘处理的报酬。大约每十分钟左右，Jing 的挖掘计算机与全球上千个相似的系统展开竞争，为一个交易的区块找出解而竞速。((("Proof-of-Work algorithm")))((("mining and consensus", "Proof-of-Work algorithm")))寻找这样的一个接，即所谓的 _工作量证明_（PoW），需要在整个比特币网络上进行每秒数千万亿次的哈希操作。工作量证明的算法需要使用 SHA256 加密算法对区块的头部和一个随机数进行反复的哈希操作，直到出现一个前提模式吻合的解。第一个找到这样的解的矿工将赢得这一轮的竞赛，并将这个区块发布到区块链中。

Jing 的挖掘生意始于 2010 年，当时他使用一台非常快的桌面型电脑寻找新区块的工作量证明。随着更多的矿工加入比特币网络，问题的难度飞速增长。很快，Jing 和其他的矿工将设备升级为更专门的硬件，比如用于游戏终端的高端专用图形处理单元（GPU）。在写作本书时，问题的难度是如此之高，以至于只有使用((("application-specific integrated circuits (ASIC)")))特定应用程序整合电路（ASIC）进行挖掘才有利可图，ASIC 实质上是将数百总挖掘算法印刷在硬件中，在一个芯片中并行地运行。((("mining pools", "defined")))Jing 的公司还参加了 _矿池_，这很像允许几个参与者分享他们的努力和回报的彩票池。现在 Jing 的公司运营着一个仓库，上千台 ASIC 矿工一天 24 小时地挖掘着比特币。公司通过出售挖掘而来的比特币来支付电力成本，同时创造一些收入。

=== 挖掘区块中的交易

((("blocks", "mining transactions in")))新的交易从用户的钱包和其他应用程序源源不断地流入网络。当它们被比特币节点看到时，它们就被加入到一个由每个节点维护的，临时的未验证交易池中。当矿工构建一个新区块时，它们将未验证的交易从这个池中移动到新的区块中，然后试图使用挖掘算法（工作量证明）来证明这个新区块的合法性。挖掘的处理在<<mining>>中有详细的解说。

交易被加入新的区块，根据最高交易费优先和几个其他的准则进行排序。每个矿工会在它从网络上收到前一个区块时 —— 知道它已经输掉了上一轮竞赛 —— 开始处理一个新的交易区块的挖掘。它会立即创建一个新区块，使用交易和前一个区块的指纹填充它，并开始为这个新区块计算工作量证明。每个矿工都会向它的区块中加入一个特殊的交易，将比特币报酬（目前是 12.5 个新比特币）外加区块中所有交易的交易费之和支付给它自己。如果它找到一个使区块合法的解，那么它就会因为它的成功区块被加入了全局区块链而“赢得”这份报酬，同时它添加的回报交易变为可花费的。((("mining pools", "operation of")))参加了矿池的 Jing，将他的软件设置为创建一个将报酬交给矿池地址的新区块。从那里，报酬将会按照 Jing 和其他矿工在上一轮竞赛中做出贡献的比例发放给每一个人。

((("candidate blocks")))((("blocks", "candidate blocks")))Alice 的交易被网络发现并加入到未验证的交易池中。一旦被挖掘软件验证通过，它就会被加入一个新区块，称为 _候选区块_，由 Jing 的矿池生成。所有参加了这个矿池的矿工立即开始为这个候选区块计算工作量证明。在这笔交易被 Alice 的钱包第一次传送出来的大约五分钟之后，Jing 的一台 ASIC 矿工为候选区块找到了一个解并发布到网络中。一旦其他矿工验证了这个获胜的区块，它们就开始生成下一个区块的竞速了。

Jing 的获胜区块作为区块 #277316 成为了区块链的一部分，含有 420 笔交易，包括 Alice 的交易。包含 Alice 的交易的区块就被视为这笔交易的一次“确认”。

[TIP]
====
You can see the block that includes https://blockchain.info/block-height/277316[Alice's transaction].
====

((("confirmations", "role in transactions")))大约 19 分钟之后，一个新的区块，#277317，被另外一台矿工挖掘出来。因为这个新区块建立在包含 Alice 的交易的 #277316 区块之上，它为区块链加入了更多的计算，所以增强了那些交易的可信性。在包含 Alice 的交易的区块之上被挖掘出来的每一个区块都被视为对这笔交易的一次额外的确认。随着区块互相堆叠在一起，反转这笔交易的难度成指数级增长，从而使得它越来越为网络所信任。

((("genesis block")))((("blocks", "genesis block")))((("blockchain (the)", "genesis block")))在<<block-alice1>>所示的图例中，我们可以看到包含 Alice 的交易的 #277316 区块。在它下面还有 277,316 个区块（包括 #0 区块），它们在一个区块的链条中（区块链）相互链接一直到 #0 区块，也被称为 _原始区块_。随着时间的流逝，区块的“高度”不断增长，每个区块和整个链条的计算难度也不断增长。在包含 Alice 的交易的区块之后被挖掘出来的区块扮演着进一步的担保，因为它们在一个越来越长的链条上堆砌了更多的计算。根据惯例，每个经过多于六次确认的区块被认为是不可撤销的，因为要使六个区块失效并重新计算所需的计算量是极其巨大的。我们将在<<mining>>中更加详细地检视挖掘的过程以及它建立信任的方式。((("", startref="BToverview02")))((("", startref="MACover02")))

[[block-alice1]]
.Alice 的交易被纳入到 #277316 区块
image::images/mbc2_0209.png["Alice's transaction included in a block"]

=== 花费这笔交易

((("spending bitcoin", "simple-payment-verification (SPV)")))((("simple-payment-verification (SPV)")))现在 Alice 的交易被作为一个区块的一部分被嵌入到了区块链中，它是所有比特币应用都可见的分布式总账的一部分。每个比特币客户端都可以独立地将这笔交易验证为有效且可使用的。完整节点客户端可以从比特币在一个区块中诞生的那一刻开始追踪资金的源头，一笔交易一笔交易，直到它们找到 Bob 的地址。轻量客户端可以进行所谓的简化支付验证（参见<<spv_nodes>>）—— 确认交易在区块链中存在，并在它之后有几个被挖掘出来的区块，如此保证矿工将之视为有效的。

现在 Bob 可以花费这笔交易和其他交易的输出了。例如，Bob 可以通过将 Alice 的咖啡支付中得来的价值转移给承包商或供应商来向这些新的所有者进行支付。很有可能，Bob 的钱包软件会将许多小的支付聚合为一个大的支付，也许是将一天所有的比特币收益集中到一个单独的交易中。这会将各种支付聚合到一个单独的输出（以及一个单独的地址）中。聚合交易的图示参见<<transaction-aggregating>>。

在 Bob 花费从 Alice 和其他客人那里收到的支付时，它也延展了交易的链条。我们假定 Bob 为了他的新主页而向他的班加罗尔网站设计师 Gopesh 进行支付。现在交易的链条看起来就像<<block-alice2>>。

[[block-alice2]]
.Alice 的交易作为从 Joe 到 Gopesh 的交易链条的一部分
image::images/mbc2_0210.png["Alice's transaction as part of a transaction chain"]

在这一张中，我们看到了交易如何构建了将价值从一个所有者移动到另一个所有者的链条。我们还追踪了 Alice 的交易，从它在钱包中被创建的那一刻起，穿过比特币网络，直到将它记录到区块链中的矿工那里。在本书的剩余部分，我们将检视钱包、地址、签名、交易、网络、以及挖掘背后的具体技术。((("", startref="BCover02")))((("", startref="DCSover02"))) ((("", startref="UCcoffee02")))